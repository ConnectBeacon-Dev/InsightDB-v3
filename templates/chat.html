<!-- app/templates/chat.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Defense Chatbot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    :root{ --bg:#f6f7fb; --card:#fff; --muted:#6b7280; --border:#e5e7eb; --brand:#12a150;
           --user:#e8f3ff; --bot:#eefbf2; --error:#fee2e2; --shadow:0 6px 18px rgba(0,0,0,.06); }
    *{ box-sizing:border-box }
    body{ margin:0; background:var(--bg); font-family:system-ui,Arial,sans-serif; color:#0f172a; }
    header{ background:var(--brand); color:#fff; padding:14px 18px; font-weight:700; }
    main{ max-width:900px; margin:18px auto; padding:0 14px; }
    #chat{ background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:var(--shadow); height:65vh; overflow:auto; padding:16px; }
    .row{ display:flex; gap:10px; margin:12px 0; align-items:flex-start }
    .user .bubble{ background:var(--user); }
    .bot .bubble{ background:var(--bot); }
    .bubble{ max-width:75%; background:#f8fafc; border:1px solid var(--border); border-radius:14px; padding:10px 12px; white-space:pre-wrap }
    .composer{ display:flex; gap:8px; margin-top:14px }
    .composer textarea{ flex:1; resize:none; min-height:48px; max-height:160px; padding:12px 14px; border-radius:12px; border:1px solid var(--border); outline:none }
    .composer button{ background:var(--brand); color:#fff; border:none; border-radius:12px; padding:12px 18px; font-weight:700; cursor:pointer }
    .thinking{ font-style:italic; color:var(--muted) }
    .typing{ display:inline-flex; gap:6px; align-items:center }
    .dot{ width:6px; height:6px; border-radius:50%; background:#94a3b8; animation:bounce 1.2s infinite }
    .dot:nth-child(2){ animation-delay:.15s } .dot:nth-child(3){ animation-delay:.3s }
    @keyframes bounce{0%,80%,100%{opacity:.2;transform:translateY(0)}40%{opacity:1;transform:translateY(-4px)}}
  </style>
</head>
<body>
  <header>Defense India Chatbot</header>
  <main>
    <div id="chat"></div>
    <div class="composer">
      <textarea id="q" placeholder="Ask about products, ISO/NABL, capabilitiesâ€¦"></textarea>
      <button id="send">Send</button>
    </div>
  </main>

  <template id="tpl">
    <div class="row"><div class="bubble"></div></div>
  </template>

  <script>
    const chat = document.getElementById('chat');
    const q = document.getElementById('q');
    const send = document.getElementById('send');

    function add(role, text){
      const row = document.getElementById('tpl').content.firstElementChild.cloneNode(true);
      row.classList.add(role);
      row.querySelector('.bubble').innerHTML = marked.parse(text || '');
      chat.appendChild(row); chat.scrollTop = chat.scrollHeight; return row;
    }
    function thinking(){
      const n = add('bot', '<span class="thinking"><span class="typing"><span>Thinking</span><span class="dot"></span><span class="dot"></span><span class="dot"></span></span></span>');
      n.id = 'thinking'; return n;
    }

    // SSE-over-POST polyfill (ReadableStream)
    class EventSourcePolyfill {
      constructor(url, {method='GET', headers={}, payload=null} = {}) {
        this.listeners = {}; this.closed = false;
        (async () => {
          const res = await fetch(url, {method, headers, body: payload});
          const reader = res.body.getReader(); const decoder = new TextDecoder();
          let buf = '';
          while (true) {
            const {value, done} = await reader.read();
            if (done || this.closed) break;
            buf += decoder.decode(value, {stream:true});
            let idx;
            while ((idx = buf.indexOf('\\n\\n')) >= 0) {
              const raw = buf.slice(0, idx); buf = buf.slice(idx + 2);
              const lines = raw.split(/\\r?\\n/);
              let event = 'message', data = '';
              for (const line of lines) {
                if (line.startsWith('event:')) event = line.slice(6).trim();
                else if (line.startsWith('data:')) data += (data ? '\\n' : '') + line.slice(5).trim();
              }
              (this.listeners[event]||[]).forEach(cb => cb({data}));
            }
          }
        })().catch(err => (this.listeners['error']||[]).forEach(cb => cb({data: err.message})));
      }
      addEventListener(evt, cb){ (this.listeners[evt] ||= []).push(cb); }
      close(){ this.closed = true; }
    }

    async function sendQuery(){
      const text = q.value.trim(); if(!text) return;
      add('user', text); q.value = ''; const t = thinking();

      const sse = new EventSourcePolyfill('/ask_stream/', {
        method: 'POST', headers: {'Content-Type':'application/json'},
        payload: JSON.stringify({ query: text }),
      });
      let acc = '', live;
      sse.addEventListener('token', (e) => {
        t.remove();
        if (!live) live = add('bot', '');
        acc += JSON.parse(e.data);
        live.querySelector('.bubble').innerHTML = marked.parse(acc);
        chat.scrollTop = chat.scrollHeight;
      });
      sse.addEventListener('done', () => { sse.close(); });
      sse.addEventListener('error', (e) => {
        try{ t.remove(); }catch{}
        add('bot', '**Error:** ' + (e?.data || 'stream failed'));
        sse.close();
      });
    }

    send.addEventListener('click', sendQuery);
    q.addEventListener('keydown', e => { if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); sendQuery(); }});
  </script>
</body>
</html>
